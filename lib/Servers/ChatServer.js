// const Wayward             = require('./../Wayward.js');
const UsersManager = require('./../Session/UsersManager.js');
const ConnectionsManager = require('./../Session/ConnectionsManager.js');
const Util = require('./../Common/Util.js');
const http = require('http');
const socketIO = require('socket.io');
const fs = require('fs');

/**
 * A basic chat server
 * @param {object} configuration settings
 * @returns {ChatServer}
 */
const ChatServer = class ChatServer {
  constructor(config) {
    this.users = new UsersManager(this);
    this.connections = new ConnectionsManager(this);
    this.port = config.port;

    this.chatBuffer = [];
    this.chatI = 0;
    this.chatMax = 100;

    let i;
    const n = this.chatMax;
    for (i = 0; i < n; i += 1) {
      this.chatBuffer[i] = '';
    }
  }

  /**
   * Run the instance of ChatServer, begins listening for client-server connections using socket.io
   * @returns {void}
   */
  run() {
    this.net = http.createServer(this.httpHandler);
    this.io = socketIO.listen(this.net);

    this.net.listen(this.port);

    Util.log('sys', 'run', `ChatServer has started, listening on port ${this.port}...`);

    const server = this;
    this.io.sockets.on('connection', (socket) => {
      server.connection(socket);
    });
  }

  /**
   * New connection from a client to the server, sets up new Connection and User object instances
   * @param {object} socket - the socket generated by the socket.io on('connection') event
   * @returns {void}
   */
  connection(socket) {
    // cleans up any dropped users who have been gone too long
    // TODO: move this somewhere that's running at an interval
    this.connections.handleDropped();

    // setup objects representing the current user, and their network conneciton
    // we keep network connection seperate so they can drop/reconnect and maintain a user instance
    // let user = this.users.create();
    const connection = this.connections.create(socket);

    // setup all the node communication events
    this.setEvents(connection);
  }
  /**
   * Sets all the emit() events for communication between the client and server
   * @param {Connection} connection
   * @returns {void}
   */
  setEvents(connection) {
    const server = this;
    // const connection = connection;

    const events = {
      disconnect: () => {
        connection.drop();
      },

      chatMessage: (data) => {
        Util.log('in', 'chatMessage', data);

        /* let user = validateUserKey(connection.socket, data.key);
        if(!user) {
            console.log('invalid user');
            return;
        } */

        if (typeof data.msg === 'undefined' || data.msg === '') {
          return;
        }

        if (typeof data.name === 'undefined' || data.name === '') {
          return;
        }

        const d = new Date();
        const mdy = [Util.padLeft(d.getMonth() + 1), Util.padLeft(d.getDate()), d.getFullYear().toString().substr(2)].join('/');
        const hms = [Util.padLeft(d.getHours()), Util.padLeft(d.getMinutes()), Util.padLeft(d.getSeconds())].join(':');
        const dformat = `${mdy} ${hms}`;

        // let curdate = new Date();
        const outData = data;
        outData.time = Date.now();
        outData.timeStr = dformat; // curdate.toUTCString();

        // data.name = user.name;
        server.chatBuffer[server.chatI] = outData;
        server.chatI += 1;
        server.chatI %= server.chatMax;
        server.connections.emitAll('updateChat', outData);
      },
      clientReady: (data) => {
        console.log(data);
        console.log('client ready');

        let i;
        for (i = 1; ((server.chatI + i) % server.chatMax) !== server.chatI; i += 1) {
          const val = server.chatBuffer[(server.chatI + i) % server.chatMax];
          if (val) {
            connection.socket.emit('updateChat', val);
          }
        }
      },
    };

    Object.entries(events).forEach((row) => {
      const [e, event] = row;
      connection.socket.on(e, event);
    });

    connection.socket.emit('ready', {});
  }

  /**
   * Ensures the socket has a Connection instance, has provided a valid key for a User instance,
   * and that this Connection is assigned to this User instance
   * @param {object} socket - the incoming socket connection, provided by socket.io
   * @param {type} key
   * @returns {User|Boolean}
   */
  validateUserKey(socket, key) {
    let user = this.users.get(key);
    let conn;
    if (user) {
      conn = user.getConnection();
      if (conn.socket !== socket) {
        this.users.remove(user);
        user = false;
      }
    }
    return user;
  }

  /**
   * Provides index.html if people try to access the server via http, helper for socket.io
   * @param {type} req - the incoming http request
   * @param {type} res - for submitting a return status code
   * @returns {undefined}
   */
  httpHandler(req, res) {
    this.httpOn = true;
    fs.readFile(`${__dirname}/../../index.html`, (err, data) => {
      if (err) {
        res.writeHead(500);
        return res.end('Error loading index.html');
      }
      res.writeHead(200);
      res.end(data);
      return false;
    });
  }
};

module.exports = ChatServer; // node modules hook
